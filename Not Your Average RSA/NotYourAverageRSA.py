n = 18086135173395641986123054725350673124644081001065528104355398467069161310728333370888782472390469310073117314933010148415971838393130403883412870626619053053672200815153337045022984003065791405742151350233540671714100052962945261324862393058079670757430356345222006961306738393548705354069502196752913415352527
c = 9074407119435549226216306717104313210750146895081726439798095976354600576814818348656600684713830051655944443364224597709641982342039946659987121376590618828822446965847273448794324003758131816407702456966504389655568712152599077538994030379567217702587542326383955580601916478060973206347266442527564009737910
n_fact = [16904777,17673199,17730961,17901463,18145913,18313601,18646361,19459483,20010041,20013121,
          20197313,20390129,21321539,21647243,21891889,22050221,22576643,22685197, 23554169,24525821,
          24946057,24996157,25671797,25808239,25963459,27138691,27289543,27409927,27606707,27739163,
          28863719,29488469,29511773,30342329,30580789,31696261 ,31703933,31737131,31881917,33098557,33322589,33381329]

def int2Text(number, size):
    text = "".join([chr((number >> j) & 0xff)
                    for j in reversed(range(0, size << 3, 8))])
    return text.lstrip("\x00")
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - (b//a) * y, y)
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x%m


phi = 1
for i in n_fact:
    phi*=i-1

e = 65537

d = modinv(e,phi)
m = pow(c,d,n)
print(int2Text(m,len(str(m))))